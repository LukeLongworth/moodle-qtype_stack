/*  Author Luke Longworth
    University of Canterbury
    Copyright (C) 2024 Luke Longworth

    This program is free software: you can redistribute it or modify
    it under the terms of the GNU General Public License version two.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>. */

/****************************************************************/
/*  Linear algebra functions for STACK                          */
/*                                                              */
/*  V0.2.3 May 2024                                             */
/*                                                              */
/****************************************************************/

/*******************************************************************************/
/* Provides convenience functions for column and row vectors for student input */
/*******************************************************************************/
texput(c,
  lambda([ex], block([ns,str,ii],
    ns: args(ex),
    str: ["\\begin{bmatrix} "],
    for ii: 1 thru length(ns) do (str: append(str, [ev(tex1(ns[ii]),simp), " \\\\ "])),
    str[length(str)]: " \\end{bmatrix}",
    simplode(str)
  ))
);

texput(r,
  lambda([ex], block([ns,str,ii],
    ns: args(ex),
    str: ["\\begin{bmatrix} "],
    for ii: 1 thru length(ns) do (str: append(str, [ev(tex1(ns[ii]),simp), " & "])),
    str[length(str)]: " \\end{bmatrix}",
    simplode(str)
  ))
);

declare([c,r],nonscalar);

/**
 * Converts c and r into matrices.
 * Works on entire expressions.
 * Returns expression unchanged if simp:true and matrices do not conform.
 * 
 * @param[expression] ex An expression that may contain c or r 
 * @return[scalar expression] The expression with c and r replaced with matrices, or the original expression if matrices do not conform
 */
vec_convert(ex):= block([ex2],
  ex2: errcatch(ev(ex,c = lambda([[ex]],transpose(matrix(ex))),r = lambda([[ex]],matrix(ex)))),
  if emptyp(ex2) then return(ex) else return(first(ex2))
);

/*******************************************************************************/
/* Predicate functions for vectors                                             */
/*******************************************************************************/

/**
 * A predicate to determine whether an expression has been converted to matrix form.
 * 
 * @param[expression] ex An expression that may contain c or r
 * @return[boolean] Does the expression contain c or r?
 */
vec_convertedp(ex):= block([ex_ops],
  ex_ops: get_ops(ex),
  if member(c,ex_ops) or member(r,ex_ops) then return(false) else return(true)
);

/** 
 * Predicate for determining whether a given object is an Mx1 matrix (a column vector)
 * Note: does not consider c a column vector. Use vec_convert before col_vecp.
 *
 * @param[expression] ex An object that may be a matrix
 * @return[boolean] Is the object an Mx1 matrix?
 */
col_vecp(ex):= block(
  if not(matrixp(ex)) then return(false)
  else return(is(second(matrix_size(ex))=1))
);

/** 
 * Predicate for determining whether a given object is a 1xN matrix (a row vector)
 * Note: does not consider r a row vector. Use vec_convert before row_vecp.
 *
 * @param[expression] ex An object that may be a matrix
 * @return[boolean] Is the object a 1xN matrix?
 */
row_vecp(ex):= block(
  if not(matrixp(ex)) then return(false)
  else return(is(first(matrix_size(ex))=1))
);

/** 
 * Predicate for determining whether a given object is a vector
 * Note: does not consider c or r a vector. Use vec_convert before vectorp.
 *
 * @param[expression] ex An object that may be a matrix
 * @return[boolean] Is the object a 1xN or Mx1 matrix?
 */
vectorp(ex):= col_vecp(ex) or row_vecp(ex);

/* TODO write function to convert row/col vectors in matrix form to c or r form */
/* Should be useful for creating teacher answers */

/**
 * Predicate to determine whether a given object is a unit vector.
 * Can handle complex vectors
 *
 * @param[matrix] ex A vector (Mx1 or 1xN matrix)
 * @return[boolean] Does this vector have a 2-norm of 1?
 */
unit_vecp(ex):= if vectorp(ex) then is(ev(ex.conjugate(ex),simp)=1) else false;

/*********************************************************************************/
/* Functions to extract parts of matrices                                        */
/*********************************************************************************/

/**
 * Take the upper triangular part of a matrix, leaving the remaining entries = 0
 *
 * @param[matrix] M An mxn matrix
 * @return[matrix] The same matrix with all entries below the diagonal set to 0
 */
triu(M):= block([Mupp,imax,jmax,ii,jj],
  Mupp: copymatrix(M),
  [imax, jmax]: ev(matrix_size(M),simp),
  for ii: 2 thru imax do block(
    ii: ev(ii,simp),
    for jj: 1 thru ev(min(ii-1, jmax),simp) do block(
      jj: ev(jj,simp),
      Mupp[ii,jj]: 0
    )
  ),
  return(Mupp)
);

/**
 * Take the lower triangular part of a matrix, leaving the remaining entries = 0
 *
 * @param[matrix] M An mxn matrix
 * @return[matrix] The same matrix with all entries above the diagonal set to 0
 */
tril(M):= transpose(triu(transpose(M)));

/**
 * Take the diagonal of a matrix, leaving the remaining entries = 0
 *
 * @param[matrix] M An mxn matrix
 * @return[matrix] The same matrix with all off-diagonal entries set to 0
 */
get_diag(M):= tril(triu(M));

/**
 * Extracts the diagonal of a matrix as a list
 *
 * @param[matrix] M An mxn matrix
 * @return[list] The diagonal entries of M as a list
 */
diag_entries(M):= ev(makelist(M[ii,ii],ii,1,lmin(matrix_size(M))),simp);

/*********************************************************************************/
/* Predicate functions for matrices                                              */
/*********************************************************************************/

/** 
 * Predicate to determine whether a matrix is upper triangular
 * i.e. Is every entry below the diagonal equal to 0?
 * Does not check whether a matrix is in row echelon form
 *
 * @param[matrix] M An mxn matrix
 * @return[boolean] Is this matrix upper triangular?
 */
triup(M):= if matrixp(M) then is(M = triu(M)) else false; 

/** 
 * Predicate to determine whether a matrix is lower triangular
 * i.e. Is every entry above the diagonal equal to 0?
 *
 * @param[matrix] M An mxn matrix
 * @return[boolean] Is this matrix lower triangular?
 */
trilp(M):= if matrixp(M) then is(M = tril(M)) else false;

/** 
 * Predicate to determine whether a matrix is diagonal
 * i.e. Is every off-diagonal entry equal to 0?
 *
 * @param[matrix] M An mxn matrix
 * @return[boolean] Is this matrix diagonal?
 */
diagp(M):= triup(M) and trilp(M);

/** 
 * Predicate to determine whether a matrix is in row echelon form
 * i.e. Is every zero-row below all non-zero rows and does the pivot in each row appear to the right of the previous pivot?
 * Optionally checks whether each pivot is equal to 1
 * No RREFp function is given, as rref(M) is unique
 *
 * @param[matrix] M An mxn matrix
 * @param[boolean] normalise_pivots Optional: If true is given here, then pivots are required to be equal to 1
 * @return[boolean] Is this matrix in row echelon form?
 */
REFp(M,[normalise_pivots]):= block([isREF,pivot_row,m,n,jj,ii],
  if emptyp(normalise_pivots) then normalise_pivots: false else normalise_pivots: first(normalise_pivots),
  isREF: matrixp(M),
  if isREF then block(
    pivot_row: 0,
    [m, n]: matrix_size(M),
    for jj: 1 thru n do block(
      jj: ev(jj,simp),
      if is(pivot_row < m) then block(
        if is(M[ev(pivot_row+1,simp),jj] # 0) then block(
          pivot_row: ev(pivot_row + 1,simp),
          if normalise_pivots and is(M[ev(pivot_row,simp),jj] # 1) then isREF: false
        ),
        for ii: ev(pivot_row+1,simp) thru m do block(
          ii: ev(ii,simp),
          if is(M[ii,jj] # 0) then isREF: false
        )
      )
    )
  ),
  return(isREF)
);

/** 
 * Is a given object a square matrix?
 * i.e. Does the matrix have the same number of rows as columns?
 *
 * @param[matrix] M a matrix
 * @return[boolean] Is M a square matrix?
 */
squarep(M):= block([isSquare],
  isSquare: false,
  if matrixp(M) then block(
    if is(apply("=",matrix_size(M))) then isSquare: true
  ),
  return(isSquare)
);

/** 
 * Is a given object a diagonalisable matrix?
 * i.e. Is there an invertible matrix P and diagonal matrix D such that P^^-1 . M . P = D?
 *
 * @param[matrix] M a matrix
 * @return[boolean] Is M a diagonalisable matrix?
 */
diagonalisablep(M):= if squarep(M) then ev(diagp(dispJordan(jordan(M))),simp) else false;

/** 
 * Is a given object a symmetric matrix?
 * i.e. Is M = M^T? 
 * NOTE: The native function symmetricp() does the same thing and more, but is currently banned.
 *
 * @param[matrix] M a matrix
 * @return[boolean] Is M a symmetric matrix?
 */
sym_p(M):= if squarep(M) then is(M = ev(transpose(M),simp)) else false; 

/** 
 * Is a given object an invertible matrix?
 * i.e. Is there a matrix M^^-1 such that M^^-1 . M = M . M^^-1 = I?
 *
 * @param[matrix] M a matrix
 * @return[boolean] Is M an invertible matrix?
 */
invertiblep(M):= block([isInvertible],
  isInvertible: false,
  if squarep(M) then block(
    if ev(is(determinant(M)#0),simp) then isInvertible: true
  ),
  return(isInvertible)
);

/** 
 * Is a given object a matrix with orthogonal columns?
 * i.e. for any two distinct columns v1 and v2, is v1 . v2 = 0?
 *
 * @param[matrix] M a matrix
 * @return[boolean] Does M have orthogonal columns?
 */
orthogonal_columnsp(M):= ev(diagp(transpose(M).M),simp);

/** 
 * Is a given object a matrix with orthonormal columns?
 * i.e. Is M^T . M = I? For columns v_i and v_j, is v_i . v_i = 1 and v_i . v_j = 0?
 * Useful when analysing QR factorisation for rectangular matrices
 *
 * @param[matrix] M a matrix
 * @return[boolean] Does M have orthonormal columns?
 */
orthonormal_columnsp(M):= if matrixp(M) then is(ev(transpose(M).M,simp) = ident(second(matrix_size(M)))) else false;

/** 
 * Is a given object an orthogonal matrix?
 * i.e. Is M^T . M = M . M^T = I?
 *
 * @param[matrix] M a matrix
 * @return[boolean] Is M an orthogonal matrix?
 */
orth_matrixp(M):= orthonormal_columnsp(M) and orthonormal_columnsp(transpose(M));

/*********************************************************************************/
/* Functions to convert objects into standard forms                              */
/*********************************************************************************/

/* It is feasible that different institutions will prefer students to enter their answers in different ways */
/* linearalgebra.mac prefers to work with either lists of lists (not distinguishing between column and row
   vectors) or matrices whose columns are vectors of interest. */

/**
 * Takes collections of vectors and returns a list of lists.
 * The vectors themselves may be different objects. Supported objects include:
 * * 1xN or Mx1 matrices
 * * Lists
 * * Vectors using c or r notation
 * * Sets, ntuples
 * Other inert functions like sequence should work too, but 
 * The collection may be a list, set, ntuple, span, or matrix
 * If given a matrix, then returns the columns as a list, with each column also being a list.
 *
 * @param[] ex A list, set, ntuple or span containing vectors as matrices, lists, c, r, sets or ntuples, or a matrix
 * @return[list] A list of lists
 */
make_list_of_lists(ex):= block([op1],
  op1: safe_op(ex),
  /* TODO: What if given a single vector? */
  if not(member(op1,["[","ntuple","{","span","matrix"])) then return(ex),
  ex: vec_convert(ex),
  if vectorp(ex) then return([list_matrix_entries(ex)]),
  if is(op1="matrix") then return(args(transpose(ex))),
  ex: args(ex),
  ex: map(lambda([ex2],if vectorp(ex2) then list_matrix_entries(ex2) else args(ex2)),ex),
  return(ex)
);

/**
 * Given a list of lists, return the matrix that has those sub-lists as columns.
 * Naming convention from numpy
 * If the sub-lists do not conform then returns the list of lists instead
 * Note: row_stack is absent because the remaining functions that accept matrices assume that we are considering columns.
 *
 * @param[list] ex a list of lists. Each sub-list must be the same length
 * @return[matrix] A matrix whose columns are the entries of ex
 */
column_stack(ex):= block([ex2],
  ex2: errcatch(transpose(apply(matrix,args(ex)))),
  if emptyp(ex2) then return(ex2) else return(first(ex2))
);

/* TODO function to convert list of lists to list of column vectors. */

/*********************************************************************************/
/* Comparison functions                                                          */
/*********************************************************************************/

/**
 * Given a list of lists or a matrix, determine whether the list elements or columns are linearly independent.
 * If ex is a matrix, it checks for full column rank, not row rank. To check for full rank generally, use invertiblep.
 * 
 * @param[list or matrix] ex Either a list of lists (use make_list_of_lists if needed) or a matrix
 * @return[boolean] Is the collection of vectors linearly independent?
 */
lin_indp(ex):= block(
  if matrixp(ex) then return(is(rank(ex) = ev(second(matrix_size(ex)),simp)))
  else ex: column_stack(ex),
  if matrixp(ex) then return(is(rank(ex) = ev(second(matrix_size(ex)),simp))),
  return(false)
);

/**
 * Given a pair of matrices, check whether they are row equivalent.
 * i.e. can one matrix be transformed into the other with elementary row operations?
 *
 * @param[matrix] ex a mxn matrix
 * @param[matrix] ta a mxn matrix
 * @return[boolean] Are ex and ta row equivalent?
 */
row_equiv(ex,ta):= block(
  if matrixp(ex) and matrixp(ta) then (
    return(is(ev(rref(ex),simp) = ev(rref(ta),simp)))
  )
);

/**
 * Given a pair of matrices, check whether they are column equivalent.
 * i.e. can one matrix be transformed into the other with elementary column operations?
 *
 * @param[matrix] ex a mxn matrix
 * @param[matrix] ta a mxn matrix
 * @return[boolean] Are ex and ta column equivalent?
 */
col_equiv(ex,ta):= row_equiv(transpose(ex),transpose(ta));

/**
 * Given two lists of lists, determine whether they span the same subspace.
 * i.e. Is each element of ex linearly dependent on ta and vice versa?
 * Note: This does not check for redundancies. To check whether two bases are equivalent, use this function in conjunction with lin_indp.
 * 
 * @param[list] ex A list of lists. Each sub-list must be the same length
 * @param[list] ta A list of lists. Each sub-list must be the same length
 * @return[boolean] Do the two lists of vectors span the same subspace?
 */
subspace_equiv(ex,ta):= block([ex_rref,ta_rref],
  ex_rref: errcatch(ev(sublist(args(rref(apply(matrix,ex))),lambda([ex2],not(every(lambda([ex3],is(ex3=0)),ex2)))),simp)),
  if emptyp(ex_rref) then return(false) else ex_rref: first(ex_rref),
  ta_rref: errcatch(ev(sublist(args(rref(apply(matrix,ta))),lambda([ta2],not(every(lambda([ta3],is(ta3=0)),ta2)))),simp)),
  if emptyp(ta_rref) then return(false) else ta_rref: first(ta_rref),
  return(is(ev(ex_rref,simp)=ev(ta_rref,simp)))
);

/* TODO: eigenvectorp(v,M).
   What is actually useful functionality here? A predicate that checks
   whether a given vector is an eigenvector of a given matrix? Should
   we check that it corresponds to an optionally given eigenvalue? Do
   we want an equivalent eigenvaluep(L,M) function?

eigenvectorp(v,M):= block(
  if matrixp(v) then block(
    if is(first(matrix_size(v))=1) then v: transpose(v)
  ) else if listp(v) then v: transpose(v)
  else if ntuplep(v) then v: transpose(args(v)),
  if is(second(matrix_size(M))#first(matrix_size(v))) then return(false),
  return(not(lin_indp([ev(M.v,simp), v])) and is(rank(v)=1))
);
*/

/*********************************************************************************/
/* Some useful functions to perform routine tasks or extend existing functions   */
/*********************************************************************************/

/**
 * Given a list of lists or a matrix, remove linearly dependent entries/columns.
 * Intended to be used to "trim down" to a basis when redundancies exist.
 * Works from left to right, so the first instance of redundancy is removed in each case
 * 
 * @param[list or matrix] ex A list of lists or a matrix
 * @return[list or matrix] ex but with dependent entries or columns removed
 */
remove_dep(ex):= block([ex_op,n_max,jj,ii],
  ex_op: "list",
  if matrixp(ex) then block(ex: args(transpose(ex)), ex_op: "matrix"),
  ex: ev(sublist(ex,lambda([ex2],not(zeromatrixp(matrix(ex2))))),simp),
  if emptyp(ex) or is(length(ex)=1) then return(ex),
  n_max: length(ex),
  jj: 2,
  for ii: 2 thru n_max do block(
    ii: ev(ii,simp),
    if not(lin_indp(firstn(ex,jj))) then ex: append(firstn(ex,ev(jj-1,simp)),lastn(ex,ev(length(ex)-jj,simp)))
    else jj: ev(jj+1,simp),
    if is(jj>length(ex)) then return(ex)
  ),
  if is(ex_op="matrix") then ex: transpose(apply(matrix,ex)),
  return(ex)
);

/**
 * Map significantfigures over a matrix
 * Should this be core functionality? Surely when given a matrix the base sigfigsfun
   or significantfigures function could do this by mapping itself over the arguments
   and re-constructing the matrix. 
 * Explicitly only runs over a matrix, list, or number
 * 
 * @param[matrix] ex A matrix of numbers (also accepts lists or numbers)
 * @param[positive integer] n The number of significant figures desired.
 */
sf_map(ex,n):= block([rows],
  if matrixp(ex) then block(
    return(apply(matrix,map(lambda([ex2],significantfigures(ex2,n)),args(ex))))
  ) else if listp(ex) or ev(numberp(ex),simp) then return(significantfigures(ex,n))
  else return(ex)
);

/**
 * Construct a diagonal matrix of size m by n with diagonal given as a list
 * Similar to native function diag which builds a block diagonal matrix, but instead
   is intended for numerical diagonals of rectangular matrices.
 * Intended use case is to extend a reduced SVD into a full SVD
 * If the whole diagonal does not fit in an mxn matrix, then it truncates d.
 * If d is not long enough to fill an mxn matrix, remaining diagonal entries are set to 0.
 *
 * @param[list] d A list of numbers to go on the diagonal
 * @param[positive integer] m The number of rows in the desired matrix
 * @param[positive integer] n The number of columns in the desired matrix
 * @return[matrix] A mxn matrix with d as the diagonal
 */
diagmatrix_like(d, m, n):= block([M,ii],
  M: zeromatrix(m, n),
  for ii: 1 thru ev(min(m, n, length(d)),simp) do block(
    ii: ev(ii,simp),
    M[ii,ii]: d[ii]
  ),
  return(M)
);

/**
 * Returns the 2-norm of a matrix as a float
 * i.e. returns the largest singular value as a float
 * Note: I don't know if this has a good use case in STACK. I would happily remove this if this feels out of place, as I don't 
   anticipate using this in my course regularly.
 * 
 * @param[matrix] M the matrix whose norm is desired
 * @return[float] The 2-norm of M, or und if M is not a matrix.
 */
mat_norm2(M):= block([svs],
  if matrixp(M) then block(
    svs: ev(float(map(lambda([ex],sqrt(cabs(ex))),first(eigenvalues(transpose(M).M)))),simp),
    return(ev(lmax(svs),simp))
  ) else return(und)
);

/**
 * Returns the condition number of a matrix based on the 2-norm as a float
 * i.e. returns the ratio of the largest singular value to the smallest singular value as a float
 * If M is singular, then und is returned instead.
 * Note: I don't know if this has a good use case in STACK. I would happily remove this if this feels out of place, as I don't 
   anticipate using this in my course regularly.
 * 
 * @param[matrix] M the matrix whose condition number is desired
 * @return[float] The 2-condition number of M, or und if M is not an invertible matrix.
 */
mat_cond2(M):= block([svs,cond2],
  cond2: und,
  if invertiblep(M) then block(
    svs: ev(float(map(lambda([ex],sqrt(cabs(ex))),first(eigenvalues(transpose(M).M)))),simp),
    cond2: ev(lmax(svs)/lmin(svs),simp)
  ),
  return(cond2)
);

/** 
 * Solve the matrix equation Ax = b given matrix A and column vector (or list) b.
 * Optionally will find a least squares solution
 * Always returns a general solution if one exists, even in the least squares case
 * If a single solution is required, use pseudoinverse(A) . b instead.
 * 
 * @param[matrix] A An mxn matrix
 * @param[matrix] b A mx1 matrix (or a list with m entries)
 * @param[boolean] lstsq Optional: if given true then a least squares solution will be obtained. If false or omitted, only exact solutions obtained.
 * @return[matrix] The general solution to Ax = b. If no solution exists and lstsq is not true, then matrix([]) is returned.
 */
mat_solve(A,b,[lstsq]):= block([m,n,vars,eqns,sol],
  if emptyp(lstsq) then lstsq: false else lstsq:first(lstsq),
  if listp(b) then b: transpose(b),
  [m, n]: matrix_size(A),
  if ev(is(first(matrix_size(b))#m),simp) then return(matrix([])),
  vars: rest(stack_var_makelist(tmp,n)),
  if lstsq then AT: transpose(A) else AT: ident(m),
  eqns: list_matrix_entries(ev((AT . A) . transpose(vars) - (AT . b),simp)),
  sol: map(rhs,linsolve(eqns,vars)),
  if emptyp(sol) then return(matrix(sol)) else return(transpose(matrix(sol)))
);

/** 
 * Given a list of lists or a matrix, make a basis for R^m where m = length of each vector. 
 * If you don't want to expand to R^m, use remove_dep instead (it is called here too)
 * Optionally will make this basis orthonormal, mostly useful when the existing basis is orthogonal but not R^m
 * Arguably "basisify" is a poor name - suggestions welcome before published
 *
 * @param[matrix or list] M A matrix or list of lists
 * @param[boolean] orth Optional: if true then returned basis will be orthonormal. Note that this may remove some basis vectors if they are not already orthogonal.
 * @return[matrix or list] A basis for R^m where m is the length of each vector in M
 */

basisify(M,[orth]):= block([ex_op,m,n,vecs,new_vecs,ii],
  if emptyp(orth) then orth: false else orth: first(orth),
  ex_op: "matrix",
  if listp(M) then block(M: column_stack(M), ex_op: "list"),
  if not(lin_indp(M)) then M: remove_dep(M),
  [m, n]: matrix_size(M),
  vecs: args(transpose(M)),
  new_vecs: args(ident(m)),
  for ii: 1 thru m do block(
    ii: ev(ii,simp),
    if lin_indp(append(vecs,[new_vecs[ii]])) then vecs: append(vecs,[new_vecs[ii]])
  ),
  if orth then block(
    vecs: ev(gramschmidt(apply(matrix,vecs)),simp),
    vecs: ev(map(lambda([ex],ex/sqrt(ex.ex)),vecs),simp)
  ),
  if is(ex_op="matrix") then return(transpose(apply(matrix,vecs))) else return(vecs)
);

/**
 * Maps the gcd (greatest common divisor) function across a list iteratively
 * 
 * @param[list] ex A list of numbers
 * @return[number] The greatest common divisor of all elements in ex
 */
lgcd(ex):= block([ex_gcd,ii],
  ex_gcd: first(ex),
  for ii: 2 thru length(ex) do block(
    ii: ev(ii,simp),
    ex_gcd: gcd(ex_gcd,ex[ii])
  ),
  return(ex_gcd)
);

/**
 * Given a vector (or list) return the shortest possible parallel vector with integer entries.
 * Also multiplies by -1 if all entries are negative
 * Very nice for eigenvector problems.
 * 
 * @param[matrix or list] v a list or a Mx1 or 1xN matrix
 * @return[matrix or list] v, but scaled by a constant such that all entries are the smallest possible integers
 */
integerify(v):= block([v_op],
  v_op: "list",
  if vectorp(v) then (v_op: "matrix", v: list_matrix_entries(v)),
  tmp: ev(lgcd(v),simp),
  if ev(is(tmp#0),simp) then v: ev(v/tmp,simp),
  if ev(every(lambda([ex],is(signum(ex)=-1)),v),simp) then v: ev(-v,simp),
  if is(v_op="matrix") then return(transpose(v)) else return(v)
);

/* We have columnspace and nullspace functions already. The author keeps assuming that 
   rowspace must exist too, but it doesn't. The nullTspace function was added for 
   completeness' sake, and finds the nullspace of M^T. We could call it the cokernel
   function, but since maxima uses nullspace rather than kernel this feels inappropriate. */
/**
 * Returns the row space of a matrix as a collection of column vectors. 
 * Output is the inert function span, the same as columnspace gives.
 *
 * @param[matrix] M a matrix
 * @return[span] A span of column vectors
 */
rowspace(M):= ev(columnspace(transpose(M)),simp);

/**
 * Returns the cokernel of a matrix (the null space of its transpose) as a collection of column vectors. 
 * Output is the inert function span, the same as nullspace gives.
 *
 * @param[matrix] M a matrix
 * @return[span] A span of column vectors
 */
nullTspace(M):= ev(nullspace(transpose(M)),simp);

/**
 * Computes the Rayleigh quotient
 * Defined as (Ax).x/(x.x)
 * 
 * @param[matrix] M a mxn matrix 
 * @param[matrix] v a nx1 matrix
 * @return[number] the Rayleigh quotient of M and v
 */
Rayleigh(M,v):= ev((conjugate(transpose(v)) . M . v) / (conjugate(transpose(v)) . v),simp);

/**
 * Compute the algebraic multiplicity of an eigenvalue. 
 * Returns 0 if L is not an eigenvalue of M.
 *
 * @param[matrix] M a square matrix
 * @param[number] L an eigenvalue of M
 * @return[non-negative integer] the algebraic multiplicity of L in M. 0 if L is not an eigenvalue of M
 */
alg_mult(M,L):= block([evals,ii],
  if squarep(M) then block(
    evals: ev(eigenvalues(M),simp),
    if not(member(L,first(evals))) then return(0),
    ii:ev(first(sublist_indices(first(evals),lambda([ex],is(ex=L)))),simp),
    return(second(evals)[ii])
  )
);

/**
 * Compute the geometric multiplicity of an eigenvalue. 
 * Returns 0 if L is not an eigenvalue of M.
 *
 * @param[matrix] M a square matrix
 * @param[number] L an eigenvalue of M
 * @return[non-negative integer] the geometric multiplicity of L in M. 0 if L is not an eigenvalue of M
 */
geo_mult(M,L):= block([evals,evects,ii],
  if squarep(M) then block(
    [evals, evects]: ev(eigenvectors(M),simp),
    if not(member(L,first(evals))) then return(0),
    ii:ev(first(sublist_indices(first(evals),lambda([ex],is(ex=L)))),simp),
    return(length(evects[ii]))
  )
);

/**
 * Find the matrix that projects orthogonally onto the column space of M
 * Computed by removing linearly dependent columns and then using M.(M^T.M)^^-1.M^T
 *
 * @param[matrix] M An mxn matrix
 * @return[matrix] A symmetric, idempotent mxm matrix that projects mx1 vectors into the columnspace of M
 */
projection_matrix(M):= block([reduced_M],
  if ev(zeromatrixp(M),simp) then return(0),
  reduced_M: mat_unblocker(matrix(args(ev(columnspace(M),simp)))),
  return(ev(reduced_M . invert(mat_unblocker(matrix([transpose(reduced_M) . reduced_M]))) . transpose(reduced_M),simp))
);

/*********************************************************************************/
/* Matrix factorisations                                                         */
/*********************************************************************************/

/* Overall notes: 
   - These are in no way efficient functions, but seem to be fine for small 
     matrices with carefully deployed variants. 
   - I'm not convinced these add much to the package, but it felt wrong to not
     include them in a linear algebra package.
   - In most cases, teachers should begin with the factorisation, compute the 
     original matrix, and ask students to work backwards to your KNOWN answer.
*/ 

/* PM = LU */
/* The built-in functions throw errors at annoying times and require two function calls. */
/* TODO: Surely we can make a better function that works for rectangular matrices? */
/* get_PLU(M):= block(
  if invertiblep(M) then return(ev(get_lu_factors(lu_factor(M)),simp)) else return([])
); */

/**
 * M = QR
 * M must have full column rank
 * Q has orthonormal columns that span the columnspace of M
 * R is upper triangular
 *
 * @param[matrix] M a matrix with full column rank
 */
QR(M):= block([cols,Q,R],
  if is(rank(M)#second(matrix_size(M))) then return([]),
  cols: ev(gramschmidt(transpose(M)),simp),
  cols: ev(map(lambda([ex],ex/sqrt(ex.ex)),cols),simp),
  Q: transpose(apply(matrix,cols)),
  R: ev(transpose(Q).M,simp),
  return([Q,R])
);

/**
 * M = P.J.P^^-1
 * J is in Jordan normal form
 * P is invertible and made up of generalised eigenvectors of M
 * This really just calls existing functions in one go and avoids annoying errors.
 *
 * @param[matrix] M a square matrix
 * @return[list] A list of two matrices: [P, J] such that J is in Jordan form and M = P . J . P^^-1. Returns empty list if M is not a square matrix
 */
get_Jordan_form(M):= block([jordan_info,J,P],
  if not(squarep(M)) then return([]),
  jordan_info: ev(jordan(M),simp),
  J: ev(dispJordan(jordan_info),simp),
  P: ev(ModeMatrix(M,jordan_info),simp),
  return([P,J])
);

/**
 * M = P.D.P^^-1
 * M must be diagonalisable (i.e. all eigenvalues must have matching geometric and algebraic multiplicities)
 * P is invertible and contains the eigenvectors of M
 * D is diagonal and contains the eigenvalues of M
 * If M is symmetric it will automatically orthogonally diagonalise
 *
 * @param[matrix] M a diagonalisable matrix
 * @return[list] A list of two matrices: [P, D] such that D is diagonal and M = P . D . P^^-1. Returns empty list if M is not diagonalisable
 */
diagonalise(M):= block([P,D],
  if not(squarep(M)) then return([]),
  [P, D]: get_Jordan_form(M),
  if sym_p(M) then P: ev(transpose(apply(matrix,map(lambda([ex],ex/sqrt(ex.ex)),args(transpose(P))))),simp),
  if diagp(D) then return([P,D]) else return([])
);

/**
 * Reduced SVD
 * M = U.S.V^T with M as a rank r mxn matrix
 * S is an rxr invertible diagonal matrix containing the sorted non-zero singular values of M
 * V and U have orthonormal columns, with V nxr and U mxr
 *
 * @param[matrix] An mxn matrix
 * @return[list] A list of 3 matrices [U,S,VT] such that U has orthonormal columns, VT has orthonormal rows, S is invertible diagonal, and M = U.S.VT
 */
SVD_red(M):= block([MTM,V,S2,components,n,S,U,ii],
  if ev(zeromatrixp(M),simp) then return([matrix([]),matrix([]),matrix([])]),
  MTM: ev(transpose(M).M,simp),
  if atom(MTM) then MTM: matrix([MTM]),
  [V, S2]: diagonalise(MTM),
  /* TODO: does this work? */
  V: first(QR(V)),
  components: ev(makelist([S2[ii,ii],col(V,ii)],ii,1,second(matrix_size(MTM))),simp),
  components: ev(reverse(sort(components)),simp),
  components: ev(sublist(components,lambda([ex],is(first(ex)#0))),simp),
  n: length(components),
  S: zeromatrix(n,n),
  S[1,1]: ev(sqrt(first(first(components))),simp),
  V: second(first(components)),
  U: ev(M.V/S[1,1],simp),
  if atom(U) then U: matrix([U]),
  if is(n>1) then block(
    for ii: 2 thru n do block(
      ii: ev(ii,simp),
      S[ii,ii]: ev(sqrt(first(components[ii])),simp),
      V: addcol(V,second(components[ii])),
      U: addcol(U,ev(M.second(components[ii])/S[ii,ii],simp))
    )
  ),
  return([U,S,transpose(V)])
);

/**
 * M^+ = V.S^+.U^T 
 * Moore-penrose pseudoinverse.
 * I'm convinced this routine exists somewhere in a package, because I've used it before in other maxima terminals, but I was unable to find it.
 * Most commonly used to find minimal least squares solution to Ax = b using A^+ . b
 *
 * @param[matrix] M
 * @return[matrix] The moore-penrose pseudoinverse of M
 */
pinv(M):= block([U,S,VT],
  if ev(zeromatrixp(M),simp) then return(M),
  [U, S, VT]: SVD_red(M),
  return(ev(transpose(VT) . invert(S) . transpose(U),simp))
);

/**
 * Full SVD
 * M = U.S.V^T with M as a rank r mxn matrix
 * S is an mxn diagonal matrix containing the sorted singular values of M
 * V and U are orthogonal matrices, with V nxn and U mxm
 *
 * @param[matrix] An mxn matrix
 * @return[list] A list of 3 matrices [U,S,VT] such that U is mxm orthogonal, VT is nxn orthogonal, S is mxn diagonal, and M = U.S.VT
 */
SVD(M):= block([U,S,VT],
  [U, S, VT]: SVD_red(M),
  if is(U=matrix([])) then U: ident(first(matrix_size(M))) else U: basisify(U,true),
  if is(VT=matrix([])) then VT: ident(second(matrix_size(M))) else VT: transpose(basisify(transpose(VT),true)),
  S: diagmatrix_like(diag_entries(S),first(matrix_size(M)),second(matrix_size(M))),
  return([U,S,VT])
);

/*********************************************************************************/
/* Automatically formats a system of linear equations                            */
/*********************************************************************************/

/* TODO:
   - Needs another pass to fix 0 = 0 equations
   - Perhaps we want an extra function that takes A, x and b for matrix A,
     symbolic vector x, and constant vector b and then runs this?
   - Doesn't have s_test_case yet because the string output will be ridiculous
*/

/* disp_eqns helper functions for displaying minus signs and removing one coefficients etc */
s_in(ex):= if ev(is(signum(ex)=-1),simp) then "-" else "+"; /* returns the sign of a coefficient as a string, assuming 0 is positive */
s_first(ex):= if ev(is(signum(ex)=-1),simp) then "-" else ""; /* Altered version of above that doesn't return + for leading coefficient */
one_zero_remover(ex):= if ev(is(ex=1) or is(ex=0),simp) then "" else if is(ex=-1) then "-" else ev(ex,simp); /* scrubs out unwanted ones and zeros */
delete_if_zero(ex,var):= if is(ex=0) then "" else var; /* returns nothing if the coefficient is zero, otherwise returns the coefficient */

/* Give equations in standard form (i.e. constant on RHS), give variables in order you want them displayed */
/* local variable p will be a gradually growing list of strings that eventually get stitched together */
disp_eqns(eqns,vars):= block([m,n,p,pivot,ii,jj,v,a],
  n: length(eqns), /* n = number of equations */
  m: length(vars), /* m = number of variables */
  p: ["\\begin{array}"], /* begin the LaTeX array that will house the system of equations */
  p: append(p,[" {r",simplode(ev(makelist("cr",ii,1,m),simp)),"}"]), /* define the column alignments */
  for ii: 1 thru n do block(
    ii: ev(ii,simp),
    pivot: false, /* each row will have a pivot, assume false until we find it */
    v: vars[1], /* v is the variable we are looking at in this column */
    a: ev(coeff(lhs(eqns[ii]),v),simp), /* find coefficient of v */
    if is(a#0) and not(pivot) then pivot: true, /* If the coefficient is non-zero, we have found our pivot! */
    /* p: append(p,[simplode([if pivot then s_first(a) else "",one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]),  If this is a pivot, display normally, otherwise do nothing */
    if pivot then p: append(p, [simplode([s_first(a),one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]), 
    for jj: 2 thru m do block(
      jj: ev(jj,simp),
      v: vars[jj],
      a: ev(coeff(lhs(eqns[ii]),v),simp),
      if is(a#0) then p: append(p,[simplode(["& ", if pivot then s_in(a) else ""," & ",one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]) else p: append(p,["& & "]),
      if is(a#0) and not(pivot) then pivot: true
    ),/*TODO: what about 0=0? Currently displays as "=0"*/
    p: append(p,[simplode(["& = &",tex1(rhs(eqns[ii]))])]),
    if is(ii#n) then p: append(p,["\\\\"])
  ),
  p: append(p,["\\end{array}"]),
  return(simplode(p))
);
