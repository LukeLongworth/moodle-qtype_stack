/*  Author Luke Longworth
    University of Canterbury
    Copyright (C) 2024 Luke Longworth

    This program is free software: you can redistribute it or modify
    it under the terms of the GNU General Public License version two.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>. */

/****************************************************************/
/*  Linear algebra functions for STACK                         */
/*                                                              */
/*  V0.2 March 2024                                             */
/*                                                              */
/****************************************************************/

/*******************************************************************************/
/* Provides convenience functions for column and row vectors for student input */
/*******************************************************************************/
texput(c,
  lambda([ex], block(
    ns: args(ex),
    str: ["\\begin{bmatrix} "],
    for ii: 1 thru length(ns) do (str: append(str, [ev(ns[ii],simp), " \\\\ "])),
    str[length(str)]: " \\end{bmatrix}",
    simplode(str)
  ))
);

texput(r,
  lambda([ex], block(
    ns: args(ex),
    str: ["\\begin{bmatrix} "],
    for ii: 1 thru length(ns) do (str: append(str, [ev(ns[ii],simp), " & "])),
    str[length(str)]: " \\end{bmatrix}",
    simplode(str)
  ))
);

/* Manually convert student answers to the appropriate vector form. Needs simp false. */
vec_convert(sa):= ev(sa,
                     c = lambda([[ex]],transpose(matrix(ex))),
                     r = lambda([[ex]],matrix(ex))
                    );

/* Automatically converts answers like c(1,2,3) to matrix([1],[2],[3]) etc. May make the above function obsolete. */
/* TODO which approach to take: vec_convert or defining c and r as functions? */
c([ex]):= transpose(matrix(ex));
r([ex]):= matrix(ex);

s_test_case(c(1,2,3),matrix([1],[2],[3]));
s_test_case(c(1,2),matrix([1],[2]));
s_test_case(r(1,2,3),matrix([1,2,3]));
s_test_case(r(1,2),matrix([1,2]));

/*********************************************************************************/
/* Take the upper triangular part of a matrix, leaving the remaining entries = 0 */
/*********************************************************************************/

triu(M):= block([Mupp,imax,jmax,ii,jj],
  Mupp: copymatrix(M),
  [imax, jmax]: ev(matrix_size(M),simp),
  for ii: 2 thru imax do block(
    ii: ev(ii,simp),
    for jj: 1 thru ev(min(ii-1, jmax),simp) do block(
      jj: ev(jj,simp),
      Mupp[ii,jj]: 0
    )
  ),
  return(Mupp)
);

s_test_case(triu(matrix([1,2,3],[4,5,6],[7,8,9])),matrix([1,2,3],[0,5,6],[0,0,9]));
s_test_case(triu(matrix([1,2,3],[4,5,6],[7,8,9],[10,11,12])),matrix([1,2,3],[0,5,6],[0,0,9],[0,0,0]));
s_test_case(triu(matrix([1,2,3,4],[4,5,6,7],[7,8,9,10])),matrix([1,2,3,4],[0,5,6,7],[0,0,9,10]));

/*********************************************************************************/
/* Take the lower triangular part of a matrix, leaving the remaining entries = 0 */
/*********************************************************************************/

tril(M):= transpose(triu(transpose(M)));

s_test_case(tril(matrix([1,2,3],[4,5,6],[7,8,9])),matrix([1,0,0],[4,5,0],[7,8,9]));
s_test_case(tril(matrix([1,2,3],[4,5,6],[7,8,9],[10,11,12])),matrix([1,0,0],[4,5,0],[7,8,9],[10,11,12]));
s_test_case(tril(matrix([1,2,3,4],[4,5,6,7],[7,8,9,10])),matrix([1,0,0,0],[4,5,0,0],[7,8,9,0]));

/*********************************************************************************/
/* Takes the diagonal of a matrix, leaving the remaining entries = 0             */
/*********************************************************************************/

get_diag(M):= tril(triu(M));

s_test_case(get_diag(matrix([1,2,3],[4,5,6],[7,8,9])),matrix([1,0,0],[0,5,0],[0,0,9]));
s_test_case(get_diag(matrix([1,2,3],[4,5,6],[7,8,9],[10,11,12])),matrix([1,0,0],[0,5,0],[0,0,9],[0,0,0]));
s_test_case(get_diag(matrix([1,2,3,4],[4,5,6,7],[7,8,9,10])),matrix([1,0,0,0],[0,5,0,0],[0,0,9,0]));

/*********************************************************************************/
/* Predicate functions about the shape of a matrix                               */
/*********************************************************************************/

/* Is the matrix upper triangular? */
triup(M):= is(M = triu(M)); 

/* Is the matrix lower triangular? */
trilp(M):= is(M = tril(M));

/* Is the matrix diagonal? */
diagp(M):= triup(M) and trilp(M);

s_test_case(triup(ident(5)),true);
s_test_case(trilp(ident(5)),true);
s_test_case(diagp(ident(5)),true);
s_test_case(triup(zeromatrix(5,4)),true);
s_test_case(trilp(zeromatrix(5,4)),true);
s_test_case(diagp(zeromatrix(5,4)),true);

s_test_case(triup(matrix([1,2,3],[4,5,6],[7,8,9])),false);
s_test_case(triup(matrix([1,2,3],[0,5,6],[0,0,9])),true);
s_test_case(triup(matrix([1,2,3],[4,5,6],[7,8,9],[10,11,12])),false);
s_test_case(triup(matrix([1,2,3],[0,5,6],[0,0,9],[0,0,0])),true);
s_test_case(triup(matrix([1,2,3,4],[4,5,6,7],[7,8,9,10])),false);
s_test_case(triup(matrix([1,2,3,4],[0,5,6,7],[0,0,9,10])),true);

s_test_case(trilp(matrix([1,2,3],[4,5,6],[7,8,9])),false);
s_test_case(trilp(matrix([1,0,0],[4,5,0],[7,8,9])),true);
s_test_case(trilp(matrix([1,2,3],[4,5,6],[7,8,9],[10,11,12])),false);
s_test_case(trilp(matrix([1,0,0],[4,5,0],[7,8,9],[10,11,12])),true);
s_test_case(trilp(matrix([1,2,3,4],[4,5,6,7],[7,8,9,10])),false);
s_test_case(trilp(matrix([1,0,0,0],[4,5,0,0],[7,8,9,0])),true);

s_test_case((simp:false,diagp(matrix([1,0],[1-1,1]))),false);

/* Is the matrix in row echelon form (not reduced)? */

REFp(M,[normalise_pivots]):= block([isREF,pivot_row,m,n,jj,ii],
  if emptyp(normalise_pivots) then normalise_pivots: false else normalise_pivots: first(normalise_pivots),
  isREF: true,
  pivot_row: 0,
  [m, n]: matrix_size(M),
  for jj: 1 thru n do block(
    jj: ev(jj,simp),
    if is(pivot_row < m) then block(
      if is(M[ev(pivot_row+1,simp),jj] # 0) then block(
        pivot_row: ev(pivot_row + 1,simp),
        if normalise_pivots and is(M[ev(pivot_row,simp),jj] # 1) then isREF: false
      ),
      for ii: ev(pivot_row+1,simp) thru m do block(
        ii: ev(ii,simp),
        if is(M[ii,jj] # 0) then isREF: false
      )
    )
  ),
  return(isREF)
);

s_test_case(REFp(ident(4)),true);
s_test_case(REFp(ev(2*ident(4),simp)),true);
s_test_case(REFp(ev(2*ident(4),simp),true),false);
s_test_case(REFp(matrix([2,1,1],[0,0,3],[0,0,0],[0,0,0])),true);
s_test_case(REFp(matrix([2,1,1],[0,0,3],[0,0,0],[0,0,0]),true),false);
s_test_case(REFp(matrix([2,1,1],[0,0,3],[0,0,0],[0,0,0]),false),true);
s_test_case(REFp(matrix([2,1,1],[0,0,0],[0,0,3],[0,0,0])),false);
s_test_case(REFp(matrix([1,1,1,1,1,1],[0,1,1,1,1,1],[0,0,0,1,1,1],[0,0,0,0,0,1])),true);
s_test_case(REFp(matrix([1,1,1,1,1,1],[0,1,1,1,1,1],[0,0,0,1,1,1],[0,0,0,0,0,1]),true),true);
s_test_case(REFp(matrix([1,1,1,1,1,1],[0,1,1,1,1,1],[0,0,1,0,1,1],[0,0,0,0,0,1])),true);
s_test_case(REFp(matrix([1,2,3],[0,5,6])),true);
s_test_case(REFp(matrix([1,2,3],[4,5,6])),false);
s_test_case(REFp(matrix([1,2,3],[0,5,6],[0,8,9])),false);

/*********************************************************************************/
/* Returns the diagonal of a matrix as a list                                    */
/*********************************************************************************/

diag_entries(M):= ev(makelist(M[ii,ii],ii,1,lmin(matrix_size(M))),simp);

s_test_case(diag_entries(ident(3)),[1,1,1]);
s_test_case(diag_entries(matrix([1,0,0],[0,2,0],[0,0,3],[0,0,0])),[1,2,3]);
s_test_case(diag_entries(matrix([3,0,0,0],[0,2,0,0],[0,0,1,0])),[3,2,1]);

/*********************************************************************************/
/* Returns a diagonal matrix of size m by n with given diagonal                  */
/*********************************************************************************/

diagmatrix_like(d, m, n):= block([M,ii],
  M: zeromatrix(m, n),
  for ii: 1 thru ev(min(m, n, length(d)),simp) do block(
    ii: ev(ii,simp),
    M[ii,ii]: d[ii]
  ),
  return(M)
);

s_test_case(diagmatrix_like([1,1,1],3,3),ident(3));
s_test_case(diagmatrix_like([1,2,3],3,4),matrix([1,0,0,0],[0,2,0,0],[0,0,3,0]));
s_test_case(diagmatrix_like([1,2,3],4,3),matrix([1,0,0],[0,2,0],[0,0,3],[0,0,0]));
s_test_case(diagmatrix_like([1,2,3],4,4),matrix([1,0,0,0],[0,2,0,0],[0,0,3,0],[0,0,0,0]));
s_test_case(diagmatrix_like([1,2,3],2,3),matrix([1,0,0],[0,2,0]));
s_test_case(diagmatrix_like([1,2,3],3,2),matrix([1,0],[0,2],[0,0]));

/*********************************************************************************/
/* Predicate function to test whether a set of vectors is linearly independent   */
/*********************************************************************************/
/* If given a matrix, it checks whether it has full column rank */
/* If given a list of atoms, it treats it as a single vector and returns true */
/* If given a list, set, ntuple or span of lists and/or matrices, it converts 
   the matrices to lists, checks that all lists are the same length, and checks
   whether the matrix with these vectors as rows has full row rank */

lin_indp(M):= block(
  if matrixp(M) then return(is(rank(M) = ev(second(matrix_size(M)),simp)))
  else if setp(M) then M: listify(M)
  else if ntuplep(M) or safe_op(M)="span" then M: args(M),
  if every(atom,M) then return(true),
  M: map(lambda([ex], if matrixp(ex) then list_matrix_entries(ex) else ex),M),
  if every(lambda([ex],length(ex)=length(first(M))),M) then return(is(rank(apply(matrix,M)) = ev(first(matrix_size(apply(matrix,M))),simp))),
  return(false)
);

s_test_case(lin_indp(matrix([1,2],[4,5],[7,8])),true);
s_test_case(lin_indp(matrix([1,2,3],[4,5,6],[7,8,9])),false);
s_test_case(lin_indp(matrix([1,2,3],[4,5,6])),false);
s_test_case(lin_indp([[1,2],[4,5],[7,8]]),false);
s_test_case(lin_indp([[1,4,7],[2,5,8]]),true);
s_test_case(lin_indp({[1,2],[4,5],[7,8]}),false);
s_test_case(lin_indp({[1,4,7],[2,5,8]}),true);
s_test_case(lin_indp(ntuple([1,2],[4,5],[7,8])),false);
s_test_case(lin_indp(ntuple([1,4,7],[2,5,8])),true);
s_test_case(lin_indp(span([1,2],[4,5],[7,8])),false);
s_test_case(lin_indp(span([1,4,7],[2,5,8])),true);
s_test_case(lin_indp([transpose([1,4,7]),[2,5,8]]),true);
s_test_case(lin_indp({transpose([1,4,7]),matrix([2,5,8])}),true);

/*********************************************************************************/
/* Maps the significantfigures function over a matrix                            */
/*********************************************************************************/
/* Should this be core functionality? Surely when given a matrix the base sigfigsfun
   or significantfigures function could do this by mapping itself over the arguments
   and re-constructing the matrix. */

sf_map(ex,n):= block([rows],
  if matrixp(ex) then block(
    return(apply(matrix,map(lambda([ex2],significantfigures(ex2,n)),args(ex))))
  ) else if listp(ex) or ev(numberp(ex),simp) then return(significantfigures(ex,n))
  else return(ex)
);

s_test_case(sf_map(1/3,2),0.33);
s_test_case(sf_map(1/3,3),0.333);
s_test_case(sf_map(12345,2),12000);
s_test_case(sf_map(12345,3),12300);
s_test_case(sf_map(1.5,1),2);
s_test_case(sf_map(2.5,1),3);

s_test_case(sf_map([1/3,12345],2),[0.33,12000]);
s_test_case(sf_map(matrix([1/3,12345]),2),matrix([0.33,12000]));
s_test_case(sf_map(matrix([1/3],[12345]),2),matrix([0.33],[12000]));
s_test_case(sf_map(matrix([1/3,12345],[1/4,5/4]),2),matrix([0.33,12000],[0.25,1.3]));
s_test_case(sf_map({1/3,1/4},1),{1/3,1/4});

/*********************************************************************************/
/* Returns the 2-norm of a matrix and 2-condition number of an invertible matrix */
/*********************************************************************************/
/* I don't know if this has a good use case in a CAS like Maxima.
   I would happily remove this if this feels out of place, as I don't 
   anticipate using this in my course regularly. */

mat_norm2(M):= block([svs],
  if matrixp(M) then block(
    svs: ev(float(map(lambda([ex],sqrt(cabs(ex))),first(eigenvalues(transpose(M).M)))),simp),
    return(ev(lmax(svs),simp))
  ) else return(und)
);

s_test_case(mat_norm2(ident(2)),1.0);
s_test_case(mat_norm2(matrix([sqrt(3),2],[0,sqrt(3)])),3.0);
s_test_case(mat_norm2(matrix([1,2],[2,-2])),3.0);
s_test_case(mat_norm2(matrix([2,2],[1,0],[0,1])),3.0);
s_test_case(mat_norm2(matrix([1,1],[1,1])),2.0);
s_test_case(mat_norm2(1),und);

mat_cond2(M):= block([svs,cond2],
  cond2: und,
  if matrixp(M) then block(
    if ev(is(first(matrix_size(M))=second(matrix_size(M))),simp) then block(
      if ev(is(determinant(M)#0),simp) then block(
        svs: ev(float(map(lambda([ex],sqrt(cabs(ex))),first(eigenvalues(transpose(M).M)))),simp),
        cond2: ev(lmax(svs)/lmin(svs),simp)
      )
    )
  ),
  return(cond2)
);

s_test_case(mat_cond2(ident(2)),1.0);
s_test_case(mat_cond2(matrix([sqrt(3),2],[0,sqrt(3)])),3.0);
s_test_case(mat_cond2(matrix([1,2],[2,-2])),1.5);
s_test_case(mat_cond2(1),und);
s_test_case(mat_cond2(matrix([1,1],[1,0],[0,1])),und);
s_test_case(mat_cond2(matrix([1,2],[1,2])),und);

/*********************************************************************************/
/* Is a matrix row or column equivalent to another?                              */
/*********************************************************************************/
/* Note: some behaviour may be unexpected when variables appear in either matrix,
   as row/column equivalence is unclear in instances where division by an unknown occurs */

row_equiv(ex,ta):= block(
  if matrixp(ex) and matrixp(ta) then (
    return(is(ev(rref(ex),simp) = ev(rref(ta),simp)))
  )
);

col_equiv(ex,ta):= row_equiv(transpose(ex),transpose(ta));

s_test_case(row_equiv(matrix([1,2,3],[4,5,6],[7,8,9]),matrix([1,0,-1],[0,1,2],[0,0,0])),true);
s_test_case(row_equiv(matrix([1,2,3],[4,5,6],[7,8,9]),matrix([1,0,-1],[0,1,2])),false);
s_test_case(row_equiv(matrix([1,2,3],[4,5,6],[7,8,9]),matrix([1,2,3],[0,-3,-6],[0,-6,-12])),true);
s_test_case(row_equiv(matrix([1,2,3],[4,5,6],[7,8,9]),ident(3)),false);
s_test_case(row_equiv(matrix([1,2,3],[4,5,6],[7,8,10]),ident(3)),true);
s_test_case(row_equiv(matrix([1,2,3],[4,5,6],[7,8,9]),matrix([1,3,2],[4,6,5],[7,9,8])),false);
s_test_case(row_equiv(matrix([1,2,3],[4,5,6]),matrix([1,0,-1],[0,1,2])),true);
s_test_case(row_equiv(matrix([1,2],[2,3],[1,1]),matrix([1,0],[0,1],[0,0])),true);
s_test_case(row_equiv(matrix([1,2,3],[4,5,6]),matrix([1,0,0],[0,1,0])),false);
s_test_case(row_equiv(matrix([1,2],[2,3],[1,1]),matrix([1,0],[0,0],[0,0])),false);

s_test_case(col_equiv(matrix([1,2,3],[4,5,6],[7,8,9]),ident(3)),false);
s_test_case(col_equiv(matrix([1,2,3],[4,5,6],[7,8,10]),ident(3)),true);
s_test_case(col_equiv(matrix([1,3,5],[1,1,0],[1,1,2],[1,3,3]),matrix([1/2,1/2,1/2],[1/2,-1/2,-1/2],[1/2,-1/2,1/2],[1/2,1/2,-1/2])),true);

remove_dep(ex):= block(
  ex_op: "list",
  vec_op: "list",
  if matrixp(ex) then block(ex: args(transpose(ex)), ex_op: "matrix")
  else if setp(ex) then block(ex: listify(ex), ex_op: "set")
  else if ntuplep(ex) then block(ex: args(ex), ex_op: "ntuple")
  else if is(safe_op(ex)="span") then block(ex: args(ex), ex_op: "span"),
  if matrixp(first(ex)) then vec_op: "matrix"
  else if ntuplep(first(ex)) then vec_op: "ntuple",
  ex: map(lambda([ex2], if matrixp(ex2) then list_matrix_entries(ex2) else ex2),ex),
  ex: sublist(ex,lambda([ex2],not(zeromatrixp(matrix(ex2))))),
  if emptyp(ex) or is(length(ex)=1) then return(ex),
  n_max: length(ex),
  jj: 2,
  for ii: 2 thru n_max do block(
    if not(lin_indp(firstn(ex,jj))) then ex: append(firstn(ex,jj-1),lastn(ex,length(ex)-jj))
    else jj: jj+1,
    if is(jj>length(ex)) then return(ex)
  ),
  if is(vec_op="matrix") then ex: map(transpose,ex)
  else if is(vec_op="ntuple") then ex: map(ntupleify,ex),
  if is(ex_op="matrix") then ex: transpose(apply(matrix,ex))
  else if is(ex_op="set") then ex: setify(ex)
  else if is(ex_op="ntuple") then ex: ntupleify(ex)
  else if is(ex_op="span") then ex: apply(span,ex),
  return(ex)
);

remove_dep(ex):= block(
  ex_op: "list",
  vec_op: "list",
  if matrixp(ex) then block(ex: args(transpose(ex)), ex_op: "matrix")
  else if setp(ex) then block(ex: listify(ex), ex_op: "set")
  else if ntuplep(ex) then block(ex: args(ex), ex_op: "ntuple")
  else if is(safe_op(ex)="span") then block(ex: args(ex), ex_op: "span"),
  if matrixp(first(ex)) then vec_op: "matrix"
  else if ntuplep(first(ex)) then vec_op: "ntuple",
  ex: map(lambda([ex2], if matrixp(ex2) then list_matrix_entries(ex2) else ex2),ex),
  ex: sublist(ex,lambda([ex2],not(zeromatrixp(matrix(ex2))))),
  if emptyp(ex) or is(length(ex)=1) then return(ex),
  n_max: length(ex),
  jj: 2,
  for ii: 2 thru n_max do block(
    ii: ev(ii,simp),
    if not(lin_indp(firstn(ex,jj))) then ex: append(firstn(ex,ev(jj-1,simp)),lastn(ex,ev(length(ex)-jj,simp)))
    else jj: ev(jj+1,simp),
    if is(jj>length(ex)) then return(ex)
  ),
  if is(vec_op="matrix") then ex: map(transpose,ex)
  else if is(vec_op="ntuple") then ex: map(ntupleify,ex),
  if is(ex_op="matrix") then ex: transpose(apply(matrix,ex))
  else if is(ex_op="set") then ex: setify(ex)
  else if is(ex_op="ntuple") then ex: ntupleify(ex)
  else if is(ex_op="span") then ex: apply(span,ex),
  return(ex)
);

subspace_equiv(ex,ta):= block(
  if setp(ex) then ex: listify(ex) else if ntuplep(ex) or safe_op(ex)="span" then ex: args(ex),
  if setp(ta) then ex: listify(ta) else if ntuplep(ta) or safe_op(ta)="span" then ta: args(ta),
  ex: map(lambda([ex2],if matrixp(ex2) then list_matrix_entries(ex2) else ex2),ex),
  /*ex: remove_dep(ex),*/
  ta: map(lambda([ta2],if matrixp(ta2) then list_matrix_entries(ta2) else ta2),ta),
  /*ta: remove_dep(ta),z*/
  /*return(row_equiv(apply(matrix,ex),apply(matrix,ta)))*/
  ex_rref: ev(sublist(args(rref(apply(matrix,ex))),lambda([ex2],not(every(lambda([ex3],is(ex3=0)),ex2)))),simp),
  ta_rref: ev(sublist(args(rref(apply(matrix,ta))),lambda([ta2],not(every(lambda([ta3],is(ta3=0)),ta2)))),simp),
  return(is(ev(ex_rref,simp)=ev(ta_rref,simp)))
);

/* disp_eqns helper functions for displaying minus signs and removing one coefficients etc */
s_in(ex):= if ev(is(signum(ex)=-1),simp) then "-" else "+"; /* returns the sign of a coefficient as a string, assuming 0 is positive */
s_first(ex):= if ev(is(signum(ex)=-1),simp) then "-" else ""; /* Altered version of above that doesn't return + for leading coefficient */
one_zero_remover(ex):= if ev(is(ex=1) or is(ex=0),simp) then "" else if is(ex=-1) then "-" else ev(ex,simp); /* scrubs out unwanted ones and zeros */
delete_if_zero(ex,var):= if is(ex=0) then "" else var; /* returns nothing if the coefficient is zero, otherwise returns the coefficient */

/* Give equations in standard form (i.e. constant on RHS), give variables in order you want them displayed */
/* local variable p will be a gradually growing list of strings that eventually get stitched together */
disp_eqns(eqns,vars):= block([m,n,p,pivot,ii,jj,v,a],
  n: length(eqns), /* n = number of equations */
  m: length(vars), /* m = number of variables */
  p: ["\\begin{array}"], /* begin the LaTeX array that will house the system of equations */
  p: append(p,[" {r",simplode(ev(makelist("cr",ii,1,m),simp)),"}"]), /* define the column alignments */
  for ii: 1 thru n do block(
    ii: ev(ii,simp),
    pivot: false, /* each row will have a pivot, assume false until we find it */
    v: vars[1], /* v is the variable we are looking at in this column */
    a: ev(coeff(lhs(eqns[ii]),v),simp), /* find coefficient of v */
    if is(a#0) and not(pivot) then pivot: true, /* If the coefficient is non-zero, we have found our pivot! */
    /* p: append(p,[simplode([if pivot then s_first(a) else "",one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]),  If this is a pivot, display normally, otherwise do nothing */
    if pivot then p: append(p, [simplode([s_first(a),one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]), 
    for jj: 2 thru m do block(
      jj: ev(jj,simp),
      v: vars[jj],
      a: ev(coeff(lhs(eqns[ii]),v),simp),
      if is(a#0) then p: append(p,[simplode(["& ", if pivot then s_in(a) else ""," & ",one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]) else p: append(p,["& & "]),
      if is(a#0) and not(pivot) then pivot: true
    ),
    p: append(p,[simplode(["& = &",tex1(rhs(eqns[ii]))])]),
    if is(ii#n) then p: append(p,["\\\\"])
  ),
  p: append(p,["\\end{array}"]),
  return(simplode(p))
);

mat_solve(A,b,[lstsq]):= block(
  if emptyp(lstsq) then lstsq: false else lstsq:first(lstsq),
  if listp(b) then b: transpose(b),
  [m, n]: matrix_size(A),
  if ev(is(first(matrix_size(b))#m),simp) then return(matrix([])),
  vars: rest(stack_var_makelist(tmp,n)),
  if lstsq then AT: transpose(A) else AT: ident(m),
  eqns: list_matrix_entries(ev((AT . A) . transpose(vars) - (AT . b),simp)),
  sol: map(rhs,linsolve(eqns,vars)),
  if emptyp(sol) then return(matrix(sol)) else return(transpose(matrix(sol)))
);

QR(M):= block([cols,Q,R],
  if is(rank(M)#second(matrix_size(M))) then return([]),
  cols: ev(gramschmidt(transpose(M)),simp),
  cols: ev(map(lambda([ex],ex/sqrt(ex.ex)),cols),simp),
  Q: transpose(apply(matrix,cols)),
  R: ev(transpose(Q).M,simp),
  return([Q,R])
);

squarep(M):= block(
  isSquare: false,
  if matrixp(M) then block(
    if is(apply("=",matrix_size(M))) then isSquare: true
  ),
  return(isSquare)
);

diagonalisablep(M):= block(
  if squarep(M) then return(ev(diagp(dispJordan(jordan(M))),simp)) else return(false)
);

get_Jordan_form(M):= block(
  if not(squarep(M)) then return([]),
  jordan_info: ev(jordan(M),simp),
  J: ev(dispJordan(jordan_info),simp),
  P: ev(ModeMatrix(M,jordan_info),simp),
  return([P,J])
);

sym_p(M):= is(M = ev(transpose(M),simp));

diagonalise(M):= block([P,J],
  if not(squarep(M)) then return([]),
  [P, J]: get_Jordan_form(M),
  if sym_p(M) then P: ev(transpose(apply(matrix,map(lambda([ex],ex/sqrt(ex.ex)),args(transpose(P))))),simp),
  if diagp(J) then return([P,J]) else return([])
);

SVD_red(M):= block(
  if ev(zeromatrixp(M),simp) then return([matrix([]),matrix([]),matrix([])]),
  MTM: ev(transpose(M).M,simp),
  if atom(MTM) then MTM: matrix([MTM]),
  [V, S2]: diagonalise(MTM),
  /* TODO: does this work? */
  V: first(QR(V)),
  components: ev(makelist([S2[ii,ii],col(V,ii)],ii,1,second(matrix_size(MTM))),simp),
  components: ev(reverse(sort(components)),simp),
  components: ev(sublist(components,lambda([ex],is(first(ex)#0))),simp),
  n: length(components),
  S: zeromatrix(n,n),
  S[1,1]: ev(sqrt(first(first(components))),simp),
  V: second(first(components)),
  U: ev(M.V/S[1,1],simp),
  if atom(U) then U: matrix([U]),
  if is(n>1) then block(
    for ii: 2 thru n do block(
      ii: ev(ii,simp),
      S[ii,ii]: ev(sqrt(first(components[ii])),simp),
      V: addcol(V,second(components[ii])),
      U: addcol(U,ev(M.second(components[ii])/S[ii,ii],simp))
    )
  ),
  return([U,S,transpose(V)])
);

pinv(M):= block(
  if ev(zeromatrixp(M),simp) then return(M),
  [U, S, VT]: SVD_red(M),
  return(ev(transpose(VT) . invert(S) . transpose(U),simp))
);

basisify(M,[orth]):= block(
  if emptyp(orth) then orth: false else orth: first(orth),
  if not(lin_indp(M)) then M: remove_dep(M),
  [m, n]: matrix_size(M),
  vecs: args(transpose(M)),
  new_vecs: args(ident(m)),
  for ii: 1 thru m do block(
    ii: ev(ii,simp),
    if lin_indp(append(vecs,[new_vecs[ii]])) then vecs: append(vecs,[new_vecs[ii]])
  ),
  if orth then block(
    vecs: ev(gramschmidt(apply(matrix,vecs)),simp),
    vecs: ev(map(lambda([ex],ex/sqrt(ex.ex)),vecs),simp)
  ),
  return(transpose(apply(matrix,vecs)))
);

SVD(M):= block(
  [U, S, VT]: SVD_red(M),
  if is(U=matrix([])) then U: ident(first(matrix_size(M))) else U: basisify(U,true),
  if is(VT=matrix([])) then VT: ident(second(matrix_size(M))) else VT: transpose(basisify(transpose(VT),true)),
  S: diagmatrix_like(diag_entries(S),first(matrix_size(M)),second(matrix_size(M))),
  return([U,S,VT])
);

invertiblep(M):= block(
  isInvertible: false,
  if squarep(M) then block(
    if ev(is(determinant(M)#0),simp) then isInvertible: true
  ),
  return(isInvertible)
);

get_PLU(M):= block(
  if invertiblep(M) then return(ev(get_lu_factors(lu_factor(M)),simp)) else return([])
);

unit_vecp(v):= is(ev(v.conjugate(v),simp)=1);

eigenvectorp(v,M):= block(
  if matrixp(v) then block(
    if is(first(matrix_size(v))=1) then v: transpose(v)
  ) else if listp(v) then v: transpose(v)
  else if ntuplep(v) then v: transpose(args(v)),
  if is(second(matrix_size(M))#first(matrix_size(v))) then return(false),
  return(not(lin_indp([ev(M.v,simp), v])) and is(rank(v)=1))
);

rowspace(M):= ev(columnspace(transpose(M)),simp);
nullTspace(M):= ev(nullspace(transpose(M)),simp);

lgcd(ex):= block(
  ex_gcd: first(ex),
  for ii: 2 thru length(ex) do block(
    ii: ev(ii,simp),
    ex_gcd: gcd(ex_gcd,ex[ii])
  ),
  return(ex_gcd)
);

integerify(v):= block(
  v_op: "list",
  if matrixp(v) then (v_op: "matrix", v: list_matrix_entries(v)),
  v: ev(v/lgcd(v),simp),
  if is(v_op="matrix") then return(transpose(v)) else return(v)
);

alg_mult(M,L):= block(
  if squarep(M) then block(
    evals: ev(eigenvalues(M),simp),
    if not(member(L,first(evals))) then return(0),
    ii:ev(first(sublist_indices(first(evals),lambda([ex],is(ex=L)))),simp),
    return(second(evals)[ii])
  )
);

geo_mult(M,L):= block(
  if squarep(M) then block(
    [evals, evects]: ev(eigenvectors(M),simp),
    if not(member(L,first(evals))) then return(0),
    ii:ev(first(sublist_indices(first(evals),lambda([ex],is(ex=L)))),simp),
    return(length(evects[ii]))
  )
);

Rayleigh(M,v):= ev((conjugate(transpose(v)) . M . v) / (conjugate(transpose(v)) . v),simp);

orthogonal_columnsp(M):= ev(diagp(transpose(M).M),simp);
orthonormal_columnsp(M):= is(ev(transpose(M).M,simp) = ident(second(matrix_size(M))));
orth_matrixp(M):= orthonormal_columnsp(M) and orthonormal_columnsp(transpose(M));

projection_matrix(M):= block(
  if ev(zeromatrixp(M),simp) then return(0),
  reduced_M: mat_unblocker(matrix(args(ev(columnspace(M),simp)))),
  return(ev(reduced_M . invert(mat_unblocker(matrix([transpose(reduced_M) . reduced_M]))) . transpose(reduced_M),simp))
);
