/*  Author Luke Longworth
    University of Canterbury
    Copyright (C) 2024 Luke Longworth

    This program is free software: you can redistribute it or modify
    it under the terms of the GNU General Public License version two.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>. */

/****************************************************************/
/*  Linear algebra functions for STACK                          */
/*                                                              */
/*  V0.2.3 May 2024                                             */
/*                                                              */
/****************************************************************/

/*******************************************************************************/
/* Provides convenience functions for column and row vectors for student input */
/*******************************************************************************/
texput(c,
  lambda([ex], block([ns,str,ii],
    ns: args(ex),
    str: ["\\begin{bmatrix} "],
    for ii: 1 thru length(ns) do (str: append(str, [ev(tex1(ns[ii]),simp), " \\\\ "])),
    str[length(str)]: " \\end{bmatrix}",
    simplode(str)
  ))
);

texput(r,
  lambda([ex], block([ns,str,ii],
    ns: args(ex),
    str: ["\\begin{bmatrix} "],
    for ii: 1 thru length(ns) do (str: append(str, [ev(tex1(ns[ii]),simp), " & "])),
    str[length(str)]: " \\end{bmatrix}",
    simplode(str)
  ))
);

declare([c,r],nonscalar);

/* Manually convert student answers to the appropriate vector form. */
/* If vectors do not conform then the original expression is returned. */
vec_convert(ex):= block([ex2],
  ex2: errcatch(ev(ex,c = lambda([[ex]],transpose(matrix(ex))),r = lambda([[ex]],matrix(ex)))),
  if emptyp(ex2) then return(ex) else return(first(ex2))
);

/*******************************************************************************/
/* Predicate functions for vectors                                             */
/*******************************************************************************/

/* A predicate to determine whether an expression has been converted to matrix form. */
vec_convertedp(ex):= block([ex_ops],
  ex_ops: get_ops(ex),
  if member(c,ex_ops) or member(r,ex_ops) then return(false) else return(true)
);

/* Predicates for determining whether a given object is an Mx1 or 1xN matrix (a vector) */
/* Note: excludes c() and r() by design. Use vec_convert() before these. */
col_vecp(ex):= block(
  if not(matrixp(ex)) then return(false)
  else return(is(second(matrix_size(ex))=1))
);

row_vecp(ex):= block(
  if not(matrixp(ex)) then return(false)
  else return(is(first(matrix_size(ex))=1))
);

vectorp(ex):= col_vecp(ex) or row_vecp(ex);

/* TODO write function to convert row/col vectors in matrix form to c or r form */
/* Should be useful for creating teacher answers */

/* Predicate to determine whether a given object is a unit vector. */
unit_vecp(ex):= if vectorp(ex) then is(ev(ex.conjugate(ex),simp)=1) else false;

/*********************************************************************************/
/* Functions to extract parts of matrices                                        */
/*********************************************************************************/

/* Take the upper triangular part of a matrix, leaving the remaining entries = 0 */

triu(M):= block([Mupp,imax,jmax,ii,jj],
  Mupp: copymatrix(M),
  [imax, jmax]: ev(matrix_size(M),simp),
  for ii: 2 thru imax do block(
    ii: ev(ii,simp),
    for jj: 1 thru ev(min(ii-1, jmax),simp) do block(
      jj: ev(jj,simp),
      Mupp[ii,jj]: 0
    )
  ),
  return(Mupp)
);

/* Take the lower triangular part of a matrix, leaving the remaining entries = 0 */

tril(M):= transpose(triu(transpose(M)));

/* Takes the diagonal of a matrix, leaving the remaining entries = 0             */

get_diag(M):= tril(triu(M));

/* Extracts the diagonal of a matrix as a list. */

diag_entries(M):= ev(makelist(M[ii,ii],ii,1,lmin(matrix_size(M))),simp);

/*********************************************************************************/
/* Predicate functions for matrices                                              */
/*********************************************************************************/

/* Is the matrix upper triangular? */
triup(M):= if matrixp(M) then is(M = triu(M)) else false; 

/* Is the matrix lower triangular? */
trilp(M):= if matrixp(M) then is(M = tril(M)) else false;

/* Is the matrix diagonal? */
diagp(M):= triup(M) and trilp(M);

REFp(M,[normalise_pivots]):= block([isREF,pivot_row,m,n,jj,ii],
  if emptyp(normalise_pivots) then normalise_pivots: false else normalise_pivots: first(normalise_pivots),
  isREF: true,
  pivot_row: 0,
  [m, n]: matrix_size(M),
  for jj: 1 thru n do block(
    jj: ev(jj,simp),
    if is(pivot_row < m) then block(
      if is(M[ev(pivot_row+1,simp),jj] # 0) then block(
        pivot_row: ev(pivot_row + 1,simp),
        if normalise_pivots and is(M[ev(pivot_row,simp),jj] # 1) then isREF: false
      ),
      for ii: ev(pivot_row+1,simp) thru m do block(
        ii: ev(ii,simp),
        if is(M[ii,jj] # 0) then isREF: false
      )
    )
  ),
  return(isREF)
);

/* Is a given object a square matrix? */
squarep(M):= block([isSquare],
  isSquare: false,
  if matrixp(M) then block(
    if is(apply("=",matrix_size(M))) then isSquare: true
  ),
  return(isSquare)
);

/* Is a given object a diagonalisable matrix? */
diagonalisablep(M):= if squarep(M) then ev(diagp(dispJordan(jordan(M))),simp) else false;

/* Is a given object a symmetric matrix? */
/* NOTE: The native function symmetricp() does the same thing and more, but is currently banned. */
sym_p(M):= if squarep(M) then is(M = ev(transpose(M),simp)) else false; 

/* Is a given object an invertible matrix? */
invertiblep(M):= block([isInvertible],
  isInvertible: false,
  if squarep(M) then block(
    if ev(is(determinant(M)#0),simp) then isInvertible: true
  ),
  return(isInvertible)
);

/* Is a given object a matrix with orthogonal columns? */
orthogonal_columnsp(M):= ev(diagp(transpose(M).M),simp);

/* Is a given object a matrix with orthonormal columns? */
orthonormal_columnsp(M):= if matrixp(M) then is(ev(transpose(M).M,simp) = ident(second(matrix_size(M)))) else false;

/* Is a given object an orthogonal matrix? */
orth_matrixp(M):= orthonormal_columnsp(M) and orthonormal_columnsp(transpose(M));

/*********************************************************************************/
/* Functions to convert objects into standard forms                              */
/*********************************************************************************/

/* It is feasible that different institutions will prefer students to enter their answers in different ways */
/* linearalgebra.mac prefers to work with either lists of lists (not distinguishing between column and row
   vectors) or matrices whose columns are vectors of interest. */

/* A function to convert any of the following to a list of lists:
   - op may be a list, ntuple, set, span, or matrix (considering its columns)
   - elements of the op may be lists, sets, ntuples, matrices, c, or r. */
make_list_of_lists(ex):= block([op1],
  op1: safe_op(ex),
  /* TODO: What if given a single vector? */
  if not(member(op1,["[","ntuple","{","span","matrix"])) then return(ex),
  ex: vec_convert(ex),
  if vectorp(ex) then return([list_matrix_entries(ex)]),
  if is(op1="matrix") then return(args(transpose(ex))),
  ex: args(ex),
  ex: map(lambda([ex2],if vectorp(ex2) then list_matrix_entries(ex2) else args(ex2)),ex),
  return(ex)
);

/* Given a list of lists, construct a matrix with the entries as columns. */
column_stack(ex):= block([ex2],
  ex2: errcatch(transpose(apply(matrix,args(ex)))),
  if emptyp(ex2) then return(ex2) else return(first(ex2))
);

/* TODO function to convert list of lists to list of column vectors. */

/*********************************************************************************/
/* Comparison functions                                                          */
/*********************************************************************************/

/* Given a list of lists or a matrix, determine whether the list elements or columns are linearly independent. */
lin_indp(ex):= block(
  if matrixp(ex) then return(is(rank(ex) = ev(second(matrix_size(ex)),simp)))
  else ex: column_stack(ex),
  if matrixp(ex) then return(is(rank(ex) = ev(second(matrix_size(ex)),simp))),
  return(false)
);

/* Given a pair of matrices, check whether they are row or column equivalent. */
row_equiv(ex,ta):= block(
  if matrixp(ex) and matrixp(ta) then (
    return(is(ev(rref(ex),simp) = ev(rref(ta),simp)))
  )
);

col_equiv(ex,ta):= row_equiv(transpose(ex),transpose(ta));

/* Given two lists of lists, determine whether they span the same subspace. */
/* Note: This does not check for redundancies. To check whether two bases are equivalent, 
   use this function in conjunction with lin_indp. */

subspace_equiv(ex,ta):= block([ex_rref,ta_rref],
  ex_rref: ev(sublist(args(rref(apply(matrix,ex))),lambda([ex2],not(every(lambda([ex3],is(ex3=0)),ex2)))),simp),
  ta_rref: ev(sublist(args(rref(apply(matrix,ta))),lambda([ta2],not(every(lambda([ta3],is(ta3=0)),ta2)))),simp),
  return(is(ev(ex_rref,simp)=ev(ta_rref,simp)))
);

/* TODO: eigenvectorp(v,M).
   What is actually useful functionality here? A predicate that checks
   whether a given vector is an eigenvector of a given matrix? Should
   we check that it corresponds to an optionally given eigenvalue? Do
   we want an equivalent eigenvaluep(L,M) function?

eigenvectorp(v,M):= block(
  if matrixp(v) then block(
    if is(first(matrix_size(v))=1) then v: transpose(v)
  ) else if listp(v) then v: transpose(v)
  else if ntuplep(v) then v: transpose(args(v)),
  if is(second(matrix_size(M))#first(matrix_size(v))) then return(false),
  return(not(lin_indp([ev(M.v,simp), v])) and is(rank(v)=1))
);
*/

/*********************************************************************************/
/* Some useful functions to perform routine tasks or extend existing functions   */
/*********************************************************************************/

/* Given a list of lists or a matrix, remove linearly dependent entries/columns. */
remove_dep(ex):= block([ex_op,n_max,jj,ii],
  ex_op: "list",
  if matrixp(ex) then block(ex: args(transpose(ex)), ex_op: "matrix"),
  ex: ev(sublist(ex,lambda([ex2],not(zeromatrixp(matrix(ex2))))),simp),
  if emptyp(ex) or is(length(ex)=1) then return(ex),
  n_max: length(ex),
  jj: 2,
  for ii: 2 thru n_max do block(
    ii: ev(ii,simp),
    if not(lin_indp(firstn(ex,jj))) then ex: append(firstn(ex,ev(jj-1,simp)),lastn(ex,ev(length(ex)-jj,simp)))
    else jj: ev(jj+1,simp),
    if is(jj>length(ex)) then return(ex)
  ),
  if is(ex_op="matrix") then ex: transpose(apply(matrix,ex)),
  return(ex)
);

/* Map significantfigures over a matrix */
/* Should this be core functionality? Surely when given a matrix the base sigfigsfun
   or significantfigures function could do this by mapping itself over the arguments
   and re-constructing the matrix. */

sf_map(ex,n):= block([rows],
  if matrixp(ex) then block(
    return(apply(matrix,map(lambda([ex2],significantfigures(ex2,n)),args(ex))))
  ) else if listp(ex) or ev(numberp(ex),simp) then return(significantfigures(ex,n))
  else return(ex)
);

/* Construct a diagonal matrix of size m by n with diagonal given as a list */

diagmatrix_like(d, m, n):= block([M,ii],
  M: zeromatrix(m, n),
  for ii: 1 thru ev(min(m, n, length(d)),simp) do block(
    ii: ev(ii,simp),
    M[ii,ii]: d[ii]
  ),
  return(M)
);

/* Returns the 2-norm of a matrix and 2-condition number of an invertible matrix */

/* I don't know if this has a good use case in a CAS like Maxima.
   I would happily remove this if this feels out of place, as I don't 
   anticipate using this in my course regularly. */

mat_norm2(M):= block([svs],
  if matrixp(M) then block(
    svs: ev(float(map(lambda([ex],sqrt(cabs(ex))),first(eigenvalues(transpose(M).M)))),simp),
    return(ev(lmax(svs),simp))
  ) else return(und)
);

mat_cond2(M):= block([svs,cond2],
  cond2: und,
  if invertiblep(M) then block(
    svs: ev(float(map(lambda([ex],sqrt(cabs(ex))),first(eigenvalues(transpose(M).M)))),simp),
    cond2: ev(lmax(svs)/lmin(svs),simp)
  ),
  return(cond2)
);

/* Solve the matrix equation Ax = b given matrix A and column vector (or list) b. */
/* Optional extra argument: mat_solve(A,b,true) will find the least squares solution symbolically. */
/* Note that the least squares solution may be non-unique (in the case of linearly dependent columns) */
/* For minimal least squares solution, use pinv(A) . b (see below) */
/* Always returns a matrix output. */

mat_solve(A,b,[lstsq]):= block([m,n,vars,eqns,sol],
  if emptyp(lstsq) then lstsq: false else lstsq:first(lstsq),
  if listp(b) then b: transpose(b),
  [m, n]: matrix_size(A),
  if ev(is(first(matrix_size(b))#m),simp) then return(matrix([])),
  vars: rest(stack_var_makelist(tmp,n)),
  if lstsq then AT: transpose(A) else AT: ident(m),
  eqns: list_matrix_entries(ev((AT . A) . transpose(vars) - (AT . b),simp)),
  sol: map(rhs,linsolve(eqns,vars)),
  if emptyp(sol) then return(matrix(sol)) else return(transpose(matrix(sol)))
);

/* Given a list of lists or a matrix, make a basis for R^m where m = length of each vector. */
/* If you don't want to expand to R^m, use remove_dep instead */
/* Optional input: basisify(ex,true) will make it an orthonormal basis. */

basisify(M,[orth]):= block([ex_op,m,n,vecs,new_vecs,ii],
  if emptyp(orth) then orth: false else orth: first(orth),
  ex_op: "matrix",
  if listp(M) then block(M: column_stack(M), ex_op: "list"),
  if not(lin_indp(M)) then M: remove_dep(M),
  [m, n]: matrix_size(M),
  vecs: args(transpose(M)),
  new_vecs: args(ident(m)),
  for ii: 1 thru m do block(
    ii: ev(ii,simp),
    if lin_indp(append(vecs,[new_vecs[ii]])) then vecs: append(vecs,[new_vecs[ii]])
  ),
  if orth then block(
    vecs: ev(gramschmidt(apply(matrix,vecs)),simp),
    vecs: ev(map(lambda([ex],ex/sqrt(ex.ex)),vecs),simp)
  ),
  if is(ex_op="matrix") then return(transpose(apply(matrix,vecs))) else return(vecs)
);

/* Maps the gcd (greatest common divisor) function across a list */
lgcd(ex):= block([ex_gcd,ii],
  ex_gcd: first(ex),
  for ii: 2 thru length(ex) do block(
    ii: ev(ii,simp),
    ex_gcd: gcd(ex_gcd,ex[ii])
  ),
  return(ex_gcd)
);

/* Given a vector (or list) return the shortest possible parallel vector with integer entries. */
integerify(v):= block([v_op],
  v_op: "list",
  if vectorp(v) then (v_op: "matrix", v: list_matrix_entries(v)),
  v: ev(v/lgcd(v),simp),
  if ev(every(lambda([ex],is(signum(ex)=-1)),v),simp) then v: ev(-v,simp),
  if is(v_op="matrix") then return(transpose(v)) else return(v)
);

/* We have columnspace and nullspace functions already. The author keeps assuming that 
   rowspace must exist too, but it doesn't. The nullTspace function was added for 
   completeness' sake, and finds the nullspace of M^T. We could call it the cokernel
   function, but since maxima uses nullspace rather than kernel this feels inappropriate. */

rowspace(M):= ev(columnspace(transpose(M)),simp);
nullTspace(M):= ev(nullspace(transpose(M)),simp);

/* Computes the Rayleigh quotient */
Rayleigh(M,v):= ev((conjugate(transpose(v)) . M . v) / (conjugate(transpose(v)) . v),simp);

/* Compute the algebraic and geometric multiplicity of an eigenvalue. */
/* Returns 0 if L is not an eigenvalue of M. */
alg_mult(M,L):= block([evals,ii],
  if squarep(M) then block(
    evals: ev(eigenvalues(M),simp),
    if not(member(L,first(evals))) then return(0),
    ii:ev(first(sublist_indices(first(evals),lambda([ex],is(ex=L)))),simp),
    return(second(evals)[ii])
  )
);

geo_mult(M,L):= block([evals,evects,ii],
  if squarep(M) then block(
    [evals, evects]: ev(eigenvectors(M),simp),
    if not(member(L,first(evals))) then return(0),
    ii:ev(first(sublist_indices(first(evals),lambda([ex],is(ex=L)))),simp),
    return(length(evects[ii]))
  )
);

/* Find the matrix that projects orthogonally onto the column space of M */
projection_matrix(M):= block([reduced_M],
  if ev(zeromatrixp(M),simp) then return(0),
  reduced_M: mat_unblocker(matrix(args(ev(columnspace(M),simp)))),
  return(ev(reduced_M . invert(mat_unblocker(matrix([transpose(reduced_M) . reduced_M]))) . transpose(reduced_M),simp))
);

/*********************************************************************************/
/* Matrix factorisations                                                         */
/*********************************************************************************/

/* Overall notes: 
   - These are in no way efficient functions, but seem to be fine for small 
     matrices with carefully deployed variants. 
   - I'm not convinced these add much to the package, but it felt wrong to not
     include them in a linear algebra package.
   - In most cases, teachers should begin with the factorisation, compute the 
     original matrix, and ask students to work backwards to your KNOWN answer.
*/ 

/* PM = LU */
/* The built-in functions throw errors at annoying times and require two function calls. */
/* TODO: Surely we can make a better function that works for singular and/or rectangular matrices? */
/* get_PLU(M):= block(
  if invertiblep(M) then return(ev(get_lu_factors(lu_factor(M)),simp)) else return([])
); */

/* M = QR */
QR(M):= block([cols,Q,R],
  if is(rank(M)#second(matrix_size(M))) then return([]),
  cols: ev(gramschmidt(transpose(M)),simp),
  cols: ev(map(lambda([ex],ex/sqrt(ex.ex)),cols),simp),
  Q: transpose(apply(matrix,cols)),
  R: ev(transpose(Q).M,simp),
  return([Q,R])
);

/* M = P.J.P^^-1 */
/* This really just calls existing functions in one go
   and avoids annoying errors. */
get_Jordan_form(M):= block([jordan_info,J,P],
  if not(squarep(M)) then return([]),
  jordan_info: ev(jordan(M),simp),
  J: ev(dispJordan(jordan_info),simp),
  P: ev(ModeMatrix(M,jordan_info),simp),
  return([P,J])
);

/* M = P.D.P^^-1 */
/* If M is symmetric it will automatically orthogonally diagonalise */
diagonalise(M):= block([P,D],
  if not(squarep(M)) then return([]),
  [P, D]: get_Jordan_form(M),
  if sym_p(M) then P: ev(transpose(apply(matrix,map(lambda([ex],ex/sqrt(ex.ex)),args(transpose(P))))),simp),
  if diagp(D) then return([P,D]) else return([])
);

/* Reduced SVD */
/* Always produces minimum required diagonal Sigma and associated U and V. */
SVD_red(M):= block([MTM,V,S2,components,n,S,U,ii],
  if ev(zeromatrixp(M),simp) then return([matrix([]),matrix([]),matrix([])]),
  MTM: ev(transpose(M).M,simp),
  if atom(MTM) then MTM: matrix([MTM]),
  [V, S2]: diagonalise(MTM),
  /* TODO: does this work? */
  V: first(QR(V)),
  components: ev(makelist([S2[ii,ii],col(V,ii)],ii,1,second(matrix_size(MTM))),simp),
  components: ev(reverse(sort(components)),simp),
  components: ev(sublist(components,lambda([ex],is(first(ex)#0))),simp),
  n: length(components),
  S: zeromatrix(n,n),
  S[1,1]: ev(sqrt(first(first(components))),simp),
  V: second(first(components)),
  U: ev(M.V/S[1,1],simp),
  if atom(U) then U: matrix([U]),
  if is(n>1) then block(
    for ii: 2 thru n do block(
      ii: ev(ii,simp),
      S[ii,ii]: ev(sqrt(first(components[ii])),simp),
      V: addcol(V,second(components[ii])),
      U: addcol(U,ev(M.second(components[ii])/S[ii,ii],simp))
    )
  ),
  return([U,S,transpose(V)])
);

/* M^+ = V.S^+.U^T */
/* Moore-penrose pseudoinverse. I'm convinced this routine exists somewhere in a package, 
   because I've used it before in other maxima terminals, but I was unable to find it. */
pinv(M):= block([U,S,VT],
  if ev(zeromatrixp(M),simp) then return(M),
  [U, S, VT]: SVD_red(M),
  return(ev(transpose(VT) . invert(S) . transpose(U),simp))
);

/* Full SVD */
SVD(M):= block([U,S,VT],
  [U, S, VT]: SVD_red(M),
  if is(U=matrix([])) then U: ident(first(matrix_size(M))) else U: basisify(U,true),
  if is(VT=matrix([])) then VT: ident(second(matrix_size(M))) else VT: transpose(basisify(transpose(VT),true)),
  S: diagmatrix_like(diag_entries(S),first(matrix_size(M)),second(matrix_size(M))),
  return([U,S,VT])
);

/*********************************************************************************/
/* Automatically formats a system of linear equations                            */
/*********************************************************************************/

/* TODO:
   - Needs another pass to fix 0 = 0 equations
   - Perhaps we want an extra function that takes A, x and b for matrix A,
     symbolic vector x, and constant vector b and then runs this?
   - Doesn't have s_test_case yet because the string output will be ridiculous
*/

/* disp_eqns helper functions for displaying minus signs and removing one coefficients etc */
s_in(ex):= if ev(is(signum(ex)=-1),simp) then "-" else "+"; /* returns the sign of a coefficient as a string, assuming 0 is positive */
s_first(ex):= if ev(is(signum(ex)=-1),simp) then "-" else ""; /* Altered version of above that doesn't return + for leading coefficient */
one_zero_remover(ex):= if ev(is(ex=1) or is(ex=0),simp) then "" else if is(ex=-1) then "-" else ev(ex,simp); /* scrubs out unwanted ones and zeros */
delete_if_zero(ex,var):= if is(ex=0) then "" else var; /* returns nothing if the coefficient is zero, otherwise returns the coefficient */

/* Give equations in standard form (i.e. constant on RHS), give variables in order you want them displayed */
/* local variable p will be a gradually growing list of strings that eventually get stitched together */
disp_eqns(eqns,vars):= block([m,n,p,pivot,ii,jj,v,a],
  n: length(eqns), /* n = number of equations */
  m: length(vars), /* m = number of variables */
  p: ["\\begin{array}"], /* begin the LaTeX array that will house the system of equations */
  p: append(p,[" {r",simplode(ev(makelist("cr",ii,1,m),simp)),"}"]), /* define the column alignments */
  for ii: 1 thru n do block(
    ii: ev(ii,simp),
    pivot: false, /* each row will have a pivot, assume false until we find it */
    v: vars[1], /* v is the variable we are looking at in this column */
    a: ev(coeff(lhs(eqns[ii]),v),simp), /* find coefficient of v */
    if is(a#0) and not(pivot) then pivot: true, /* If the coefficient is non-zero, we have found our pivot! */
    /* p: append(p,[simplode([if pivot then s_first(a) else "",one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]),  If this is a pivot, display normally, otherwise do nothing */
    if pivot then p: append(p, [simplode([s_first(a),one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]), 
    for jj: 2 thru m do block(
      jj: ev(jj,simp),
      v: vars[jj],
      a: ev(coeff(lhs(eqns[ii]),v),simp),
      if is(a#0) then p: append(p,[simplode(["& ", if pivot then s_in(a) else ""," & ",one_zero_remover(abs(a)),tex1(delete_if_zero(a,v))])]) else p: append(p,["& & "]),
      if is(a#0) and not(pivot) then pivot: true
    ),/*TODO: what about 0=0? Currently displays as "=0"*/
    p: append(p,[simplode(["& = &",tex1(rhs(eqns[ii]))])]),
    if is(ii#n) then p: append(p,["\\\\"])
  ),
  p: append(p,["\\end{array}"]),
  return(simplode(p))
);
